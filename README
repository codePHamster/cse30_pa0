/*
* Filename: README
* Author: Kim Pham
* Userid: cs30xod
* Description: to explain in details of pa0
* Date: Apr 10 2018
* Sources of Help: Shanfeng Feng, Thant Zaw
*/

----------------------------DESCRIPTION---------------------------------------
pa0 is a simple program that prints four pieces of information to the screen
when run: three series of numbers generated by the loop specified in the
program, and the sum of three numbers. 

----------------------------COMPILING THE PROGRAM-----------------------------
to compile this program, the user should be in pa0 directory where the source 
files and the Makefile are located, then type make to start

----------------------------RUNNING THE PROGRAM-------------------------------
to run this program, make sure to compile the program first then type ./a.out to
get started.

----------------------------SAMPLE OUTPUT-------------------------------------
normal output goes to stdout
an example of normal output:
[cs30xod@pi-cluster]:pa0$ ./a.out
1
3
5
7
9
11
13
15
17
19
21
23
25
27
29

29
27
25
23
21
19
17
15
13
11
9
7
5
3
1

1
3
5
7
9
11
13
15
17
19
21
23
25
27
29

The sum of 5 + 15 + 32 = 52

----------------------------ABNORMAL OUTPUT-------------------------------------
there is no abnormal output

----------------------------TESTING THE PROGRAM---------------------------------
the program is tested with the reference pa0test. To do that, the output to this
program is redirected to MYSOL file and the output of the sample program is
redirected to REFSOL. Both files are compared using command line tool 'diff'. If
there is some output after running diff, then it means that there are some
discrepancies between MYSOL and REFSOL and should be fixed.

----------------------------QUESTIONS-------------------------------------------
0. It is considered an integrity violation if a student submits code copied from
someone/somewhere else because it does not reflect the student's understanding
and effort put into the assignment.

1. The three compilation errors are:
in pa0.c, line 47 
	error: expected ';' before '}' token
	fix: add ';' to the end of 'printf( "%d\n", intArray[i] )
in pa0.c, line 66 
	error: expected declaration or statement at end of input
	fix: add } to match with main {
in printInOrder.c, line 26
	warning: implicit declaration of function 'fprintf'
	warning: incompatible implicatit declaration of build-in function
	'fprintf'
	fix: add #include <stdio.h> to header

2. The program does not output on the first run after successful compilation
because the while loop in initArray.c never exits. I fixed it by adding i++
to increment the variable i inside the loop, so that when it hits 'length', the
loop will exit.
The following are other runtime errors:
in printReversed.c, line 26
	error: segmentation fault
	fix: change i++ to i--
in printInOrder.c, line 25
	error: weird output of '67328'
	fix: delete the extra ';' at the end of the for loop condition
in pa0.c, line 64
	error: wrong variables in print statement
	fix: change v1,v1,v1 to v1,v2,v3
in sum3.s, line 48
	error: parameters to mov are in incorrect order
	fix: change mov r3,r0 to mov r0,r3

3. debugginge exercise
int v1 = FIRST_NUM_TO_SUM; is printed on the screen

4. When I type 'nexti', gdb moves to the next memory address to be examined

5. Typing 'continue' steps into function sum3

6. (gdb) p $r3 shows r3 to be 20

7. (gdb) p $r3 again shows r3 to be 52

8. (gdb) p $r1 or print $r1 shows r1 to be 15

9. The variable that has the value 0x00010700 is sum

10. The address of the last element of the array is 0x7efffb10
The decimal value of the hexadecimal number stored at that address is 0x1d

11. The two values are: 
0x7efffb3c is r11 (frame pointer) 
and 0x000105cc is link register

12. The value 0x00105cc points to line 192 instruction in main

13. A break point is a pausing place in a program intended for debugging. There
are multiple ways to set a breakpoint, but normally I use 'break <function>'
to set a break at a function.

14. If gdb displays
<foobar+32>:	ldr r1, [r0] 
it means you are debugging function foobar

15. Step vs next:
'step' executes until another line reached. It means that if that line happens 
to be a function call, step will go into that function.
'stepi' is like step but by machine instructions rather than source lines
'next' executes next line. Again, if that line happens to be a function call, 
next will execute that function.
'nexti' is like next but by machine instructions rather than source lines

16. $r0, $r1, etc refer to the register values

17. 
